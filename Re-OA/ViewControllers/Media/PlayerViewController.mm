////  PlayerDemoViewController.m//  PlayerDemo////  Created by apple on 11-4-2.//  Copyright __MyCompanyName__ 2011. All rights reserved.//#import "PlayerViewController.h"#import "hcnetsdk.h"#import "HikDec.h"#import <Foundation/Foundation.h>#include <stdio.h>#include <ifaddrs.h>#include <sys/socket.h>#include <sys/poll.h>#include <net/if.h>#include <map>@implementation PlayerViewController@synthesize m_nPreviewPort;@synthesize m_nPlaybackPort;@synthesize m_fp;@synthesize m_playThreadID;@synthesize m_bThreadRun;@synthesize m_lUserID;@synthesize m_lRealPlayID;@synthesize m_lPlaybackID;@synthesize m_bPreview;@synthesize m_bRecord;@synthesize m_bSoundOn;@synthesize m_bPTZL;@synthesize m_bPreset1;int g_nChan = 0;-(instancetype)initWithViewFrame:(CGRect)viewFrame{    if (self=[super init]) {        _m_playView =[ [UIView alloc] initWithFrame:viewFrame];        _m_playView.backgroundColor=[UIColor blackColor];    }    return self;}// preview callback functionvoid fRealDataCallBack_V30(LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void* pUser){    PlayerViewController *pDemo =(__bridge PlayerViewController*)pUser;    switch (dwDataType)    {        case NET_DVR_SYSHEAD:            if (dwBufSize > 0 && pDemo->m_nPreviewPort != -1)            {                if (!PlayM4_SetStreamOpenMode(pDemo->m_nPreviewPort, STREAME_REALTIME))                {                    break;                }                if (!PlayM4_OpenStream(pDemo->m_nPreviewPort, pBuffer , dwBufSize, 2*1024*1024))                {                    break;                }                pDemo->m_bPreview = 1;                [pDemo startPlayer];            }            break;        case NET_DVR_STD_AUDIODATA:        case NET_DVR_STD_VIDEODATA:        case NET_DVR_STREAMDATA:            if (dwBufSize > 0 && pDemo->m_nPreviewPort != -1)            {                if(!PlayM4_InputData(pDemo->m_nPreviewPort, pBuffer, dwBufSize))                {                    break;                }            }            break;        default:            break;    }}//playback callback functionvoid fPlayDataCallBack_V40(LONG lPlayHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,void *pUser){    PlayerViewController *pDemo = (__bridge PlayerViewController*)pUser;    int i = 0;    switch (dwDataType)    {        case NET_DVR_SYSHEAD:            if (dwBufSize > 0 && pDemo->m_nPlaybackPort != -1)            {                if(PlayM4_GetPort(&pDemo->m_nPlaybackPort) != 1)                {                  //  NSLog(@"PlayM4_GetPort failed:%d",  NET_DVR_GetLastError());                }                if (!PlayM4_SetStreamOpenMode(pDemo->m_nPlaybackPort, STREAME_FILE))                {                    break;                }                if (!PlayM4_OpenStream(pDemo->m_nPlaybackPort, pBuffer , dwBufSize, 2*1024*1024))                {                    break;                }                pDemo->m_bPreview = 0;                [pDemo startPlayer];            }            break;        case NET_DVR_STD_AUDIODATA:        case NET_DVR_STD_VIDEODATA:        case NET_DVR_STREAMDATA:            if (dwBufSize > 0 && pDemo->m_nPlaybackPort != -1)            {                for(i = 0; i < 2000; i++)                {                    if(PlayM4_InputData(pDemo->m_nPlaybackPort, pBuffer, dwBufSize))                    {                        break;                    }                    sleep(2);                }            }            break;        default:            break;    }}//preset button click up-(IBAction)presetBtnClicked:(id)sender{   // NSLog(@"presetBtnClicked");        if (m_lUserID < 0) {       // NSLog(@"Please logon a device first!");        return;    }        if (m_bPreset1 == false)    {        if (!NET_DVR_PTZPreset_Other(m_lUserID, g_nChan, GOTO_PRESET, 1))        {           // NSLog(@"GOTO_PRESET[1] failed with[%d]", NET_DVR_GetLastError());        }        else        {          //  NSLog(@"GOTO_PRESET[1] succ");        }        m_bPreset1 = true;            }    else    {        if (!NET_DVR_PTZPreset_Other(m_lUserID, g_nChan, GOTO_PRESET, 2))        {           // NSLog(@"GOTO_PRESET[2] failed with[%d]", NET_DVR_GetLastError());        }        else        {           // NSLog(@"GOTO_PRESET[2] succ");        }                m_bPreset1 = false;    }}//ptz button click up-(IBAction)ptzBtnClickedUp:(id)sender{   // NSLog(@"ptzBtnClickedUp");    if (m_bPTZL == true) {        if(!NET_DVR_PTZControl_Other(m_lUserID, g_nChan, PAN_LEFT, 1))        {          //  NSLog(@"stop PAN_LEFT failed with[%d]", NET_DVR_GetLastError());        }        else        {           // NSLog(@"stop PAN_LEFT succ");        }    }    else    {        if(!NET_DVR_PTZControl_Other(m_lUserID, g_nChan, PAN_RIGHT, 1))        {          //  NSLog(@"stop PAN_RIGHT failed with[%d]", NET_DVR_GetLastError());        }        else        {          //  NSLog(@"stop PAN_RIGHT succ");        }            }}//ptz button click-(IBAction)ptzBtnClicked:(id)sender{   // NSLog(@"ptzBtnClicked");    if (m_lUserID < 0) {      //  NSLog(@"Please logon a device first!");        return;    }    if (m_bPTZL == false)    {        if(!NET_DVR_PTZControl_Other(m_lUserID, g_nChan, PAN_LEFT, 0))        {          //  NSLog(@"start PAN_LEFT failed with[%d]", NET_DVR_GetLastError());        }        else        {          //  NSLog(@"start PAN_LEFT succ");        }        m_bPTZL = true;    }    else    {        if(!NET_DVR_PTZControl_Other(m_lUserID, g_nChan, PAN_RIGHT, 0))        {          //  NSLog(@"start PAN_RIGHT failed with[%d]", NET_DVR_GetLastError());        }        else        {          //  NSLog(@"start PAN_RIGHT succ");        }        m_bPTZL = false;    }}//sound button click-(IBAction)soundBtnClicked:(id)sender{    //NSLog(@"soundBtnClicked");    if (m_lRealPlayID < 0) {      //  NSLog(@"Please start realplay first!");        return;    }        if (m_bSoundOn == false) {        PlayM4_PlaySound(m_nPreviewPort);        m_bSoundOn = true;    }    else    {        PlayM4_StopSound();        m_bSoundOn = false;    }}// record button click-(IBAction)recordBtnClicked:(id)sender{   // NSLog(@"recordBtnClicked");    if (m_bRecord == false)    {        if (m_lRealPlayID < 0) {          //  NSLog(@"Please start realplay first!");            return;        }                NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);        NSString *documentsDirectory = [paths objectAtIndex:0];        char szFileName[256] = {0};        NSString* date;        NSDateFormatter* formatter = [[NSDateFormatter alloc]init];        [formatter setDateFormat:@"YYYY-MM-dd-hh-mm-ss"];        date = [formatter stringFromDate:[NSDate date]];        sprintf(szFileName, "%s/%s.mp4", (char*)documentsDirectory.UTF8String, (char*)date.UTF8String);        if (!NET_DVR_SaveRealData(m_lRealPlayID, szFileName)) {           // NSLog(@"NET_DVR_SaveRealData failed with[%d]", NET_DVR_GetLastError());            return;        }       // NSLog(@"NET_DVR_SaveRealData succ [%s]", szFileName);                m_bRecord = true;            }    else    {        NET_DVR_StopSaveRealData(m_lRealPlayID);        m_bRecord = false;    }}// capture button click-(IBAction)captureBtnClicked:(id)sender{   // NSLog(@"captureBtnClicked");    if (m_lRealPlayID < 0) {       // NSLog(@"Please start realplay first!");        return;    }    int nHeight = 0;    int nWidth = 0;    if (!PlayM4_GetPictureSize(m_nPreviewPort, &nWidth, &nHeight)){       // NSLog(@"PlayM4_GetPictureSize fialed with[%d]", PlayM4_GetLastError(m_nPreviewPort));        return;    }    //2cif -> 4cif    if (nWidth == 704 && (nHeight == 288 || nHeight == 240)) {        nHeight <<= 1;    }        int nSize = 5 * nWidth * nHeight;    char *pBuf = new char[nSize];    memset(pBuf, 0, nSize);    unsigned int  dwRet = 0;    if (!PlayM4_GetBMP(m_nPreviewPort, (unsigned char*)pBuf, nSize, &dwRet))    {        delete []pBuf;        pBuf = NULL;       // NSLog(@"PlayM4_GetBMP failed with[%d]", PlayM4_GetLastError(m_nPreviewPort));        return;    }        NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);    NSString *documentsDirectory = [paths objectAtIndex:0];    char szFileName[256] = {0};    NSString* date;    NSDateFormatter* formatter = [[NSDateFormatter alloc]init];    [formatter setDateFormat:@"YYYY-MM-dd hh:mm:ss"];    date = [formatter stringFromDate:[NSDate date]];        sprintf(szFileName, "%s/%s.bmp", (char*)documentsDirectory.UTF8String, (char*)date.UTF8String);        FILE *pFile = NULL;    pFile = fopen(szFileName, "wb");    fwrite(pBuf, dwRet, 1, pFile);    fclose(pFile);        delete []pBuf;    pBuf = NULL;       // NSLog(@"capture bmp succ[%s]", szFileName);    return;}// preview button Click-(void) playerBtnClicked{   // NSLog(@"liveStreamBtnClicked");        if (m_lRealPlayID == -1)    {        if(m_lUserID == -1)        {           // NSLog(@"Please login on the device first!");            return;        }                [self startPlay];                // request stream        NET_DVR_CLIENTINFO ClientInfo = {0};        ClientInfo.lChannel = g_nChan;        ClientInfo.lLinkMode = (1<<31);                m_lRealPlayID = NET_DVR_RealPlay_V30(m_lUserID, &ClientInfo, fRealDataCallBack_V30, (__bridge void*)self);        if (m_lRealPlayID == -1)        {           // NSLog(@"NET_DVR_RealPlay_V30 failed:%d",  NET_DVR_GetLastError());                        UIAlertView *alert = [[UIAlertView alloc]                                  initWithTitle:kWarningTitle                                  message:kRealPlayFailMsg                                  delegate:nil                                  cancelButtonTitle:kWarningConfirmButton                                  otherButtonTitles:nil];            [alert show];            // [alert release];            [self stopPlay];            return;        }            }    else    {        [self stopPlay];    }}//config button click-(IBAction) getcfgBtnClicked:(id)sender{   // NSLog(@"getcfgBtnClicked");        if(m_lUserID == -1)    {       // NSLog(@"Please logon a device first!");        return;    }        NET_DVR_COMPRESSIONCFG_V30 struCompress = {0};    DWORD dwRet = 0;    if (!NET_DVR_GetDVRConfig(m_lUserID, NET_DVR_GET_COMPRESSCFG_V30, g_nChan, &struCompress, sizeof(struCompress), &dwRet))    {       // NSLog(@"NET_DVR_GET_COMPRESSCFG_V30 failed with[%d]", NET_DVR_GetLastError());    }    else    {       // NSLog(@"NET_DVR_GET_COMPRESSCFG_V30 succ");    }    //set substream resolution to cif    struCompress.struNetPara.byResolution = 1;    if (!NET_DVR_SetDVRConfig(m_lUserID, NET_DVR_SET_COMPRESSCFG_V30, g_nChan, &struCompress, sizeof(struCompress)))    {       // NSLog(@"NET_DVR_SET_COMPRESSCFG_V30 failed with[%d]", NET_DVR_GetLastError());    }    else    {      //  NSLog(@"NET_DVR_SET_COMPRESSCFG_V30 succ");    }}//init player for preview- (void) startPlay{    if(PlayM4_GetPort(&m_nPreviewPort) != 1)    {      //  NSLog(@"PlayM4_GetPort failed:%d",  NET_DVR_GetLastError());    }    return;}//start player- (void) startPlayer{    [self performSelectorOnMainThread:@selector(playerPlay)                           withObject:nil                        waitUntilDone:NO];}//play,the function PlayM4_Play must be called in main thread- (void) playerPlay{    int nRet = 0;    if(m_bPreview)    {        nRet =PlayM4_Play(m_nPreviewPort,(__bridge void*) _m_playView);    }    else    {        nRet = PlayM4_Play(m_nPlaybackPort, (__bridge void*)_m_playView);    }    if (nRet != 1)    {      //  NSLog(@"PlayM4_Play fail");        [self stopPlay];        return;    }}//init player for palyback- (void) startPlayback{    if(PlayM4_GetPort(&m_nPlaybackPort) != 1)    {      //  NSLog(@"PlayM4_GetPort failed:%d",  NET_DVR_GetLastError());    }    return;}// playback button click-(IBAction) playbackBtnClicked:(id)sender{   // NSLog(@"playbackBtnClicked");    if (m_lPlaybackID == -1)    {        if(m_lUserID == -1)        {          //  NSLog(@"Please login on the device first!");            return;        }                [self startPlayback];        NET_DVR_TIME struStartTime = {0};        NET_DVR_TIME struEndTime = {0};        struStartTime.dwYear = 2014;        struStartTime.dwMonth = 7;        struStartTime.dwDay = 17;        struStartTime.dwHour =0;        struStartTime.dwMinute = 0;        struStartTime.dwSecond = 0;                struEndTime.dwYear = 2014;        struEndTime.dwMonth = 7;        struEndTime.dwDay = 17;        struEndTime.dwHour = 23;        struEndTime.dwMinute = 0;        struEndTime.dwSecond = 0;                m_lPlaybackID = NET_DVR_PlayBackByTime(m_lUserID, g_nChan, &struStartTime, &struEndTime, NULL);        if (m_lPlaybackID == -1)        {          //  NSLog(@"NET_DVR_PlayBackByTime failed:%d",  NET_DVR_GetLastError());            UIAlertView *alert = [[UIAlertView alloc]                                  initWithTitle:kWarningTitle                                  message:kRealPlayFailMsg                                  delegate:nil                                  cancelButtonTitle:kWarningConfirmButton                                  otherButtonTitles:nil];            [alert show];            //[alert release];                        [self stopPlayback];            return;        }                if (!NET_DVR_SetPlayDataCallBack_V40(m_lPlaybackID, fPlayDataCallBack_V40 , (__bridge void*)self))        {           // NSLog(@"NET_DVR_SetPlayDataCallBack_V40 failed:%d",  NET_DVR_GetLastError());            [self stopPlayback];            return;        }                if (!NET_DVR_PlayBackControl_V40(m_lPlaybackID, NET_DVR_PLAYSTART, NULL, 0, NULL, NULL))        {           // NSLog(@"NET_DVR_PlayBackControl_V40 failed:%d",  NET_DVR_GetLastError());            [self stopPlayback];            return;        }    }    else    {        [self stopPlayback];            }}// login button click-(void) loginBtnClicked{   // NSLog(@"loginBtnClicked");    // init    BOOL bRet = NET_DVR_Init();    if (!bRet)    {      //  NSLog(@"NET_DVR_Init failed");    }        NSString *documentPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0];    const char* pDir = [documentPath UTF8String];    NET_DVR_SetLogToFile(3, (char*)pDir, true);    if (m_lUserID == -1)    {        //  Get value        NSString * iP = _videoIP;        NSString * port = _videoPort;        NSString * usrName = _videoUserName;        NSString * password = _videoPassword;                DeviceInfo *deviceInfo = [[DeviceInfo alloc] init];        deviceInfo.chDeviceAddr = iP;        deviceInfo.nDevicePort = [port integerValue];        deviceInfo.chLoginName = usrName;        deviceInfo.chPassWord = password;                // check valid        if (![self validateValue:deviceInfo])        {            return;        }                // device login        NET_DVR_DEVICEINFO_V30 logindeviceInfo = {0};                // encode type        NSStringEncoding enc = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000);        m_lUserID = NET_DVR_Login_V30((char*)[deviceInfo.chDeviceAddr UTF8String],                                      deviceInfo.nDevicePort,                                      (char*)[deviceInfo.chLoginName cStringUsingEncoding:enc],                                      (char*)[deviceInfo.chPassWord UTF8String],                                      &logindeviceInfo);               // printf("iP:%s\n", (char*)[deviceInfo.chDeviceAddr UTF8String]);       // printf("Port:%d\n", deviceInfo.nDevicePort);        //printf("UsrName:%s\n", (char*)[deviceInfo.chLoginName cStringUsingEncoding:enc]);        //printf("Password:%s\n", (char*)[deviceInfo.chPassWord UTF8String]);                // login on failed        if (m_lUserID == -1)        {            UIAlertView *alert = [[UIAlertView alloc]                                  initWithTitle:kWarningTitle                                  message:kLoginDeviceFailMsg                                  delegate:nil                                  cancelButtonTitle:kWarningConfirmButton                                  otherButtonTitles:nil];            [alert show];            //[alert release];            return;        }                NET_DVR_IPPARACFG_V40 struIPPara = {0};        DWORD dwRet = 0;        NET_DVR_GetDVRConfig(m_lUserID, NET_DVR_GET_IPPARACFG_V40, 0, &struIPPara, sizeof(struIPPara), &dwRet);        if (struIPPara.dwAChanNum > 0)        {            g_nChan = 1;        }        else        {            g_nChan = struIPPara.dwStartDChan;        }                if (g_nChan <= 0) {            g_nChan = 1;        }            }    else    {        NET_DVR_Logout(m_lUserID);        NET_DVR_Cleanup();        m_lUserID = -1;            }}//stop preview-(void) stopPlay{    if (m_lRealPlayID != -1)    {        NET_DVR_StopRealPlay(m_lRealPlayID);        m_lRealPlayID = -1;    }        if(m_nPreviewPort >= 0)    {        if (!PlayM4_Stop(m_nPreviewPort))        {          //  NSLog(@"PlayM4_Stop failed");        }        if(!PlayM4_CloseStream(m_nPreviewPort))        {           // NSLog(@"PlayM4_CloseStream failed");        }        if (!PlayM4_FreePort(m_nPreviewPort))        {          //  NSLog(@"PlayM4_FreePort failed");        }        m_nPreviewPort = -1;    }}//stop playback- (void) stopPlayback{    if (m_lPlaybackID != -1)    {        NET_DVR_StopPlayBack(m_lPlaybackID);        m_lPlaybackID = -1;    }        if(m_nPlaybackPort >= 0)    {        if (!PlayM4_Stop(m_nPlaybackPort))        {           // NSLog(@"PlayM4_Stop failed");        }        if(!PlayM4_CloseStream(m_nPlaybackPort))        {          //  NSLog(@"PlayM4_CloseStream failed");        }        if (!PlayM4_FreePort(m_nPlaybackPort))        {         //   NSLog(@"PlayM4_FreePort failed");        }        m_nPlaybackPort = -1;    }}// Implement viewDidLoad to do additional setup after loading the view, typically from a nib.- (void)viewDidLoad{    m_lUserID = -1;    m_lRealPlayID = -1;    m_lPlaybackID = -1;    m_nPreviewPort = -1;    m_nPlaybackPort = -1;    m_bRecord = false;    m_bSoundOn = false;    m_bPTZL = false;    m_bPreset1 = false;    //[self starPlay];        // hide keybord    [[NSNotificationCenter defaultCenter] addObserver:self                                             selector:@selector(keyboardWillHide:)                                                 name:UIKeyboardWillHideNotification                                               object:nil];    [super viewDidLoad];}/* // Override to allow orientations other than the default portrait orientation. - (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation { // Return YES for supported orientations return (interfaceOrientation == UIInterfaceOrientationPortrait); } */- (void)viewDidUnload{        if (m_lRealPlayID != -1)    {        NET_DVR_StopRealPlay(m_lRealPlayID);        m_lRealPlayID = -1;    }        if(m_lPlaybackID != -1)    {        NET_DVR_StopPlayBack(m_lPlaybackID);        m_lPlaybackID = -1;    }        if(m_lUserID != -1)    {        NET_DVR_Logout(m_lUserID);        NET_DVR_Cleanup();        m_lUserID = -1;    }}/******************************************************************************* Function:			validateValue Description:		check valid Input:				deviceInfo － device info Output: Return:			true-valid;false-invalid *******************************************************************************/- (bool) validateValue:(DeviceInfo *)deviceInfo{    // check device address    if ([deviceInfo.chDeviceAddr compare:@""] == NSOrderedSame)    {        UIAlertView *alert = [[UIAlertView alloc]                              initWithTitle:kWarningTitle                              message:kDeviceAddrEmptyMsg                              delegate:nil                              cancelButtonTitle:kWarningConfirmButton                              otherButtonTitles:nil];        [alert show];        //[alert release];                return false;    }        // check length of device address    if ([deviceInfo.chDeviceAddr lengthOfBytesUsingEncoding:NSUTF8StringEncoding] > 32)    {        UIAlertView *alert = [[UIAlertView alloc]                              initWithTitle:kWarningTitle                              message:kDeviceAddrTooLongerMsg                              delegate:nil                              cancelButtonTitle:kWarningConfirmButton                              otherButtonTitles:nil];        [alert show];        //[alert release];                return false;    }        // whether valid ip    if (![self isValidIP:deviceInfo.chDeviceAddr])    {        UIAlertView *alert = [[UIAlertView alloc]                              initWithTitle:kWarningTitle                              message:kDeviceAddrInvalidMsg                              delegate:nil                              cancelButtonTitle:kWarningConfirmButton                              otherButtonTitles:nil];        [alert show];        //[alert release];                return false;    }        // check port    if (deviceInfo.nDevicePort == 0)    {        UIAlertView *alert = [[UIAlertView alloc]                              initWithTitle:kWarningTitle                              message:kDevicePortEmptyMsg                              delegate:nil                              cancelButtonTitle:kWarningConfirmButton                              otherButtonTitles:nil];        [alert show];        //[alert release];                return false;    }        // check username    if ([deviceInfo.chLoginName compare:@""] == NSOrderedSame)    {        UIAlertView *alert = [[UIAlertView alloc]                              initWithTitle:kWarningTitle                              message:kDeviceUserNameEmptyMsg                              delegate:nil                              cancelButtonTitle:kWarningConfirmButton                              otherButtonTitles:nil];        [alert show];        //[alert release];                return false;    }        // check username length    if ([deviceInfo.chLoginName lengthOfBytesUsingEncoding:NSUTF8StringEncoding] > 64)    {        UIAlertView *alert = [[UIAlertView alloc]                              initWithTitle:kWarningTitle                              message:kDeviceUserNameTooLongerMsg                              delegate:nil                              cancelButtonTitle:kWarningConfirmButton                              otherButtonTitles:nil];        [alert show];        //[alert release];                return false;    }        // check password length    if ([deviceInfo.chPassWord lengthOfBytesUsingEncoding:NSUTF8StringEncoding] > 16)    {        UIAlertView *alert = [[UIAlertView alloc]                              initWithTitle:kWarningTitle                              message:kDevicePasswordTooLongerMsg                              delegate:nil                              cancelButtonTitle:kWarningConfirmButton                              otherButtonTitles:nil];        [alert show];        //[alert release];                return false;    }        return true;}/******************************************************************************* Function:			isValidIP Description:		check ip Input:				ipStr － IP address Output: Return:			true-valid,false-invalid *******************************************************************************/- (bool)isValidIP:(NSString *)ipStr{    const char* ip = [ipStr cStringUsingEncoding:NSUTF8StringEncoding];        // check invalid char    int temp = 0;    for (int i = 0; i < strlen(ip); i++)    {        // <1 or > 9,invalid char        temp = (int)ip[i];        if ((temp >= 48 && temp <= 57) || temp == 46)        {            continue;        }        else        {            return false;        }    }        int n;    unsigned int a, b, c, d;    if(strlen(ip) <= 15 &&       sscanf(ip, "%3u.%3u.%3u.%3u%n", &a, &b, &c, &d, &n) >= 4       && n == static_cast<int>(strlen(ip)))    {        return (a > 0 && a <= 255 && b <= 255 && c <= 255 && d <= 255 && d > 0) || (a == 0 && b== 0 && c == 0 && d == 0);    }    return false;}/******************************************************************************* Function:			keyboardWillHide Description:		exit edit box,hide picture,controller focus change Input:				note － keyboard hide Output: Return: *******************************************************************************/- (IBAction)keyboardWillHide:(NSNotification *)note{    [UIView beginAnimations:@"login.animation" context:nil];    [UIView commitAnimations];}// hide copy and paste button- (BOOL)canPerformAction:(SEL)action withSender:(id)sender{    [UIMenuController sharedMenuController].menuVisible = NO;        return YES;}- (void)dealloc{    if (_m_playView != nil)    {        ///[m_playView release];        _m_playView = nil;    }        if (m_playThreadID != nil)    {        //[m_playThreadID release];        m_playThreadID = nil;    }        //[super dealloc];}@end